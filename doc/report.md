### Report for DHT
### 1.Chord
#### 1.1概述
在Chord算法中，可将节点构成的网络视作一个**加强版**的环。
这个环具有以下特性：
- 环上节点按唯一的64位HashId升序排列
- 在我的实现中，每个节点除了存储自身的数据外，备份且仅备份前驱节点的数据。
- 节点被强制下线时，Maintain进程会修复有问题的fingerTable，successorList和precessorNode，同时释放下线节点后继的备份数据。
- 稍详细的，对于每个节点：
   - 有路由表fingerTable，用于快速查询一个HashId（可能代表Key，也可能代表节点，其具体含义对查询没有影响）可能归属的节点。它保证了查询的复杂度在Log级别。
   - 有successorList，用于记录后继节点。这是整个DHT正确性的保证。
   - 归属自身的数据存储在data中，备份的数据存储在backup中。
   - 存储了predecessorNode，但predecessorNode的正确性不能保证，会需要经常更新。
   - 有一系列读写锁，保证并发时的正确性。
#### 1.2 复杂度
**查询数据**的复杂度的上限由fingerTable确定，每次fingerTable上的跳转可以保证离目标节点的距离会变小，且在下一个节点查询时的距离不小于当前距离的一半。对于64位HashId的Chord网络，查询的跳转次数不超过64次。

**插入和删除数据**的复杂度与查询操作同阶。插入时需要在后继节点上备份，删除时则同样需要在后继节点上删除备份。

**新节点加入网络**包含查询节点的后继与初始化节点。该节点的fingerTable可以在Maintain中逐步构建。

**节点正常退出网络**的复杂度来自移交数据与更新其他节点的fingerTable两部分。移交数据只涉及前驱和两个后继节点，更新其它节点的fingerTable则需要递归处理，但被更新到的节点数依然是log的。

**Maintain维护进程**包含三个部分。对于每个节点，分别需要：1.完善和修复fingerTable。2.完善和修复successorList。3.提醒后继节点它的前驱是自身。一共三个进程。
#### 1.3 稳定性
对于DHT网络来说，只要successorList是正确的（甚至直至需要successorList[0]，即后继节点是正确的），通过有限次Maintain即可获得正确的路由表和前驱。而在某个节点的ForeceQuit后，该节点前驱可以通过的successorList迅速更新得到正确的后继节点。
对于存储的数据来说，只要不出现相邻两个节点同时ForceQuit的极端情况，下线节点的数据都可以快速的从backup中恢复。
### 2.Kademlia
#### 2.1概述
在Kademlia算法中，可将DHT网络视作一个节点间由若干动态的边连接的图。
这个图有以下特性：
- 节点之间通过 XOR 距离度量联系，环上节点有唯一的64位HashId。
- 每个节点维护一个 kBuckets 列表，其中每个Bucket包含与该节点特定距离范围内的其他节点信息，每个Bucket至多存储k个节点。
#### 2.2 具体操作
**查找操作**：Kademlia 的查找复杂度为 $O(log N)$。在查找过程中，每个节点会与 kBuckets 中的节点进行通信，逐步逼近目标节点。

**数据存储和冗余**：Kademlia 通过将数据存储在多个节点上，提高了数据的可靠性和可用性，并通过定时重发（republish）保证数据总存储在合适的节点上。查询时，会在可能的节点中寻找，只要找到一份数据即可返回。

**节点加入和离开**：每次RemoteCall都会附带更新kBucket，这使得节点的加入和更新很自然。而太久未使用的节点会被踢出，使得节点退出无需太多额外处理。

#### 2.3 其它
与CHord相比，Kademlia存储了更多的数据和路由，有更强大的鲁棒性，这使得它的正确率能远高于Chord。

### 3.关于Go语言和TCP连接（debug）
- rpc传参中有很多注意点：1.用到的自定义结构体也需要首字母大写（可导出）2.go语言内置的list.List不能用于传参，会引发“gob encoding”，因为使用encoding包初始化结构体时，会递归地向encode指针指向的对象初始化，引发循环引用。 3.涉及指针的要格外小心，浅拷贝问题十分致命且难以发觉。
- 关于big.Int，这是一个指针类型，拷贝的时候要另外新建。完全可以在需要使用的时候直接调用getHash，从而避免很多问题。（在Kademlia的代码中我优化了这一点，传递地址时只使用string）
- 在实现chord时，RemoteCall经常返回“i/o timeout”的错误。问题原因可参考http://ningg.top/computer-basic-theory-tcp-time-wait/，具体原因为：每一个 time_wait 状态，都会占用一个本地端口，上限为 65535；当大量的连接处于 time_wait 时，新建立 TCP 连接会出错。 相应的解决方法为复用TCP连接（实现线程池）或换用UDP协议。
- 实现Chord的时候有特别多bug，但实现Kademlia时成功避免绝大部分问题。